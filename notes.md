# notes

### 2024-04-01 19:01 - thoughts on fetch and js standards

in [one of the scripts](/scrripts/create-repo.mjs), I made a comment explaining that I had to use a weird hack of fetch-enhanced because the fetch command doesn't detect and use the `HTTP_PROXY` env var -- when, in the browser, it works just fine. I was using node at the time, so I found a hack by reading the issues on node's github, and found a link to fetch-enhanced (I can't find it now), with the hack. apparently this issue has been [discussed since 2016](https://github.com/nodejs/node/issues/8381). I won't dwell on the discussion of it, because I can just use a module to perfom the action. the thing for me was the difference in behaviour between the browser and node in operation. I expected it to just work (like it does in the browser).
anyway, a few hours later that brought me to find deno -- as I was watching ryan dahl's talks on it, and he claims that js and the browser is here to stay for at least 5-10y -- which I'd probably have to agree, if not longer (it'd take a massively different system (like nosebook) to become the hub for human information, in order to dethrone the internet and browsers -- and even still, I imagine it'll be one of those slow to die technologies),-- so getting things right in the browser is always something I too have had quite an emphasis on. the browser is a generalised took for exploring all kinds of content and information, and is designed to become even more general, and not specific. I liked ryan's position on the thing and so I tried deno. the install was pretty easy (I think just a bashrc additon after running a script), and fetch just worked right away. I really liked it, and -- there's also some pretty cool stuff about the api, most notably the one about async fs events coming from watching a dir (though chokidar does a great job now, it wasn't always so easy).
the thing that eventually turned me off about deno is the subject of this entry. I've used a lot of different programming languages for a few decades now, and I've found that with some of them, I *get* the language, and it's really easy for me to program in it (it just flows). I've also used other languages, where no matter how hard I try, I simply cannot seem to wrap my head around it (C/C++) --	even though I understand the cOncept of pointers and stuff, for whatever reason, whenever I look at the code, it just looks like gobbly-gook to me. I just don't get it. I've used pointers and virtual call tables just fine in SpAsm and D just fine, so I fully understand the concept -- but it's something that happens when my brain kinda meshes with the creator of the language where I'm able to "get" the language and use it proficiently, or not. nodejs was really awesome when I first discovered it (I think 0.4-0.6 era), and I was just coming back from spain to get my legal residence in spain thing, and I was just working on getting some D programs I was writing to use epoll and stuff like that. my difficulty with understanding C made it difficult to understand, and when (another) ryan (my friend) told me about node, I immediately clicked right in with it. I too was nerding out on epoll and trying to get good performance because in tuenti we had quite a large userbase and performance matters with millions of users.
this time, when using deno though, I did not click at all, and it was a terrible process trying to figure out how to do things. looking back on it now in hindsight, it's pretty easy to see that the difference between then and now was the subject of security. back then ryan was (obviously) not too concerned with security and stuff like that, cause node can essentially do *anything* (which is what I liked), *and* it was a dynamic language, which meant no compiling: I can write code that writes code (which can do anything) -- which is very very awesome. I really flourished for quite a time in node cause it felt pretty open-ended and lots of possibilites, but this time, with all of the security stuff, the whole tthing had a feel of being locked down, and endless paranoia about something accessing something or doing something (which btw, is really weird, because I never had to give fetch permission to read HTTP_PROXY env variable, but it did).
so starting to get disillusioned with deno, I decided to try bun. one of the things that I noticed is that every release, lots and lots of bugs get fixed. it seems that there are tons and tons of "little things" that just seem to kind creep in there and cause problems -- but the author (jeremy something) is massively productive, and very quick about things (even fixing the bugs). bun, is the same way: very fast, but lot's of little quirks and stuff. anyway, I tried fetch on bun, and it also worked right away without having to tell it about proxies or anything like that -- but that was for doing DELETE and GET commands. when it came to POST, it told me I have a malformed HTTP response (I'll file a bug sometime later) -- but to keep up productivity, I decided to eventually go back to node. node has a whole load of other problems (installation is a nightmare, even on ubuntu, and it seems that all progress on anything has ground to a complete halt. they appear to be suffering from a corporate tendency I will refer to as "blowing the load in the meeting, not on the code").
anyway, I've used other languages too, and one other extremely good one I used is lua -- however, that one is also really difficult for me to use, because as I try and align my thoughts to be similar to the creator of lua (roberto), I begin to struggle quite considerably in my creativity. although the language is quite nice and has everything I could want, it too is a nightmare to install, and the documentation assumes that the person has eidetic memory (which I do not have).
like I said, each language that I've used is sorta like a weird mental puzzle to figure out, because I really have to begin to see things the same way as the creator of the language, and learn to think like they do. I really don't mind having to learn how someone else thinks, and I even find it kinda fun.
	that reminds me of a game I played, "the witness", and in it there are all of these puzzles and problems to solve. well, same thing, while playing the game, I really felt like I was getting into jon's head, but since we didn't see things the same way, I often times had to go and look up the solution (exactly like I have to do when programming). when my thinking is nearly the same as the creator (like it was for me with walter bright in the early days of D), I don't even need to read the manual or anything like that -- I just know how it works. while playing the witness, it felt to me a lot of times like I was just supposed to *know* the answer -- almost as if the game was training me to think like jon. unfortunately I didn't think like him most of the times, and I found (what I believe to be) many alternate solutions to quite a few puzzles, which seemed obvious to me, but apparently weren't for him. I may return back to finish the game, but in the process of playing it, I learned a lot about compilers and things like that -- like I somehow extracted some kind of knowledge from him just by learning to think like him.
programming languages really are an externalisation of the the creator's conceptual system (ie, their perception) into a system of conditions and rules which make the things flow. as an example, ryan mentioned in the tokyo deno talk that a npm module could read your chrome browser cache and retrieve a creditcard number -- which is theoretically possible, but I would imagine a rootkit would be more viable hack, simply because they would need to send the CC data somewhere, and when they go to retrieve it, they're guaranteed to be there (otherwise, why steal it?) -- and that example looked like something he just pulled out of the air, so obviously not well thought out -- but still is conceptually similar to the foundational desire upon which the concept of deno stands. I don't have anything close to that kind of perception, which is why I had such a terrible time with deno, but with bun, I seemed to do really well (cept hitting that minor issue lol). ryan probably perceives isolation and simplicity (along with notifications of everything that's happening) as the best form of protecton, and jeremy probably just blasts stuff out -- and though it's imperfect, it doesn't matter because it'll continue to get better -- which means high speed is the way for him to get things done. (I'm very similar) enough for now...
